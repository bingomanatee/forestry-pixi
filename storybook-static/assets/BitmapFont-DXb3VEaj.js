import{E as D,m as k,v,p as M,q as I,r as H,i as T,R as O,t as L,I as N,u as j,w as U,h as A,x as G,y as z,z as q,D as J}from"./TickerForest-7hloE1rI.js";import"./preload-helper-PPVm8Dsz.js";class K extends D{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return k(v,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return k(v,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return k(v,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return k(v,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return k(v,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners();for(const t in this.chars)this.chars[t].texture?.destroy();this.chars=null,e&&(this.pages.forEach(t=>t.texture.destroy(!0)),this.pages=null)}}const $=class Y extends K{constructor(e){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const t={...Y.defaultOptions,...e};this._textureSize=t.textureSize,this._mipmap=t.mipmap;const i=t.style.clone();t.overrideFill&&(i._fill.color=16777215,i._fill.alpha=1,i._fill.texture=M.WHITE,i._fill.fill=null),this.applyFillAsTint=t.overrideFill;const s=i.fontSize;i.fontSize=this.baseMeasurementFontSize;const n=I(i);t.overrideSize?i._stroke&&(i._stroke.width*=this.baseRenderedFontSize/s):i.fontSize=this.baseRenderedFontSize=s,this._style=i,this._skipKerning=t.skipKerning??!1,this.resolution=t.resolution??1,this._padding=t.padding??4,t.textureStyle&&(this._textureStyle=t.textureStyle instanceof H?t.textureStyle:new H(t.textureStyle)),this.fontMetrics=T.measureFont(n),this.lineHeight=i.lineHeight||this.fontMetrics.fontSize||i.fontSize}ensureCharacters(e){const t=T.graphemeSegmenter(e).filter(g=>!this._currentChars.includes(g)).filter((g,l,c)=>c.indexOf(g)===l);if(!t.length)return;this._currentChars=[...this._currentChars,...t];let i;this._currentPageIndex===-1?i=this._nextPage():i=this.pages[this._currentPageIndex];let{canvas:s,context:n}=i.canvasAndContext,a=i.texture.source;const r=this._style;let o=this._currentX,u=this._currentY,h=this._currentMaxCharHeight;const p=this.baseRenderedFontSize/this.baseMeasurementFontSize,w=this._padding*p;let x=!1;const S=s.width/this.resolution,m=s.height/this.resolution;for(let g=0;g<t.length;g++){const l=t[g],c=T.measureText(l,r,s,!1);c.lineHeight=c.height;const f=c.width*p,y=Math.ceil((r.fontStyle==="italic"?2:1)*f),W=c.height*p,b=y+w*2,F=W+w*2;if(x=!1,l!==`
`&&l!=="\r"&&l!=="	"&&l!==" "&&(x=!0,h=Math.ceil(Math.max(F,h))),o+b>S&&(u+=h,h=F,o=0,u+h>m)){a.update();const C=this._nextPage();s=C.canvasAndContext.canvas,n=C.canvasAndContext.context,a=C.texture.source,o=0,u=0,h=0}const _=f/p-(r.dropShadow?.distance??0)-(r._stroke?.width??0);if(this.chars[l]={id:l.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:_,kerning:{}},x){this._drawGlyph(n,c,o+w,u+w,p,r);const C=a.width*p,P=a.height*p,X=new O(o/C*a.width,u/P*a.height,b/C*a.width,F/P*a.height);this.chars[l].texture=new M({source:a,frame:X}),o+=Math.ceil(b)}}a.update(),this._currentX=o,this._currentY=u,this._currentMaxCharHeight=h,this._skipKerning&&this._applyKerning(t,n)}get pageTextures(){return k(v,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(e,t){const i=this._measureCache;for(let s=0;s<e.length;s++){const n=e[s];for(let a=0;a<this._currentChars.length;a++){const r=this._currentChars[a];let o=i[n];o||(o=i[n]=t.measureText(n).width);let u=i[r];u||(u=i[r]=t.measureText(r).width);let h=t.measureText(n+r).width,p=h-(o+u);p&&(this.chars[n].kerning[r]=p),h=t.measureText(n+r).width,p=h-(o+u),p&&(this.chars[r].kerning[n]=p)}}}_nextPage(){this._currentPageIndex++;const e=this.resolution,t=L.getOptimalCanvasAndContext(this._textureSize,this._textureSize,e);this._setupContext(t.context,this._style,e);const i=e*(this.baseRenderedFontSize/this.baseMeasurementFontSize),s=new M({source:new N({resource:t.canvas,resolution:i,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(s.source.style=this._textureStyle);const n={canvasAndContext:t,texture:s};return this.pages[this._currentPageIndex]=n,n}_setupContext(e,t,i){t.fontSize=this.baseRenderedFontSize,e.scale(i,i),e.font=I(t),t.fontSize=this.baseMeasurementFontSize,e.textBaseline=t.textBaseline;const s=t._stroke,n=s?.width??0;if(s&&(e.lineWidth=n,e.lineJoin=s.join,e.miterLimit=s.miterLimit,e.strokeStyle=j(s,e)),t._fill&&(e.fillStyle=j(t._fill,e)),t.dropShadow){const a=t.dropShadow,r=U.shared.setValue(a.color).toArray(),o=a.blur*i,u=a.distance*i;e.shadowColor=`rgba(${r[0]*255},${r[1]*255},${r[2]*255},${a.alpha})`,e.shadowBlur=o,e.shadowOffsetX=Math.cos(a.angle)*u,e.shadowOffsetY=Math.sin(a.angle)*u}else e.shadowColor="black",e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0}_drawGlyph(e,t,i,s,n,a){const r=t.text,o=t.fontProperties,h=(a._stroke?.width??0)*n,p=i+h/2,w=s-h/2,x=o.descent*n,S=t.lineHeight*n;let m=!1;a.stroke&&h&&(m=!0,e.strokeText(r,p,w+S-x));const{shadowBlur:g,shadowOffsetX:l,shadowOffsetY:c}=e;a._fill&&(m&&(e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0),e.fillText(r,p,w+S-x)),m&&(e.shadowBlur=g,e.shadowOffsetX=l,e.shadowOffsetY=c)}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{canvasAndContext:t,texture:i}=this.pages[e];L.returnCanvasAndContext(t),i.destroy(!0)}this.pages=null}};$.defaultOptions={textureSize:512,style:new A,mipmap:!0};let R=$;function Z(d,e,t,i){const s={width:0,height:0,offsetY:0,scale:e.fontSize/t.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};s.offsetY=t.baseLineOffset;let n=s.lines[0],a=null,r=!0;const o={width:0,start:0,index:0,positions:[],chars:[]},u=t.baseMeasurementFontSize/e.fontSize,h=e.letterSpacing*u,p=e.wordWrapWidth*u,w=e.lineHeight?e.lineHeight*u:t.lineHeight,x=e.wordWrap&&e.breakWords,S=l=>{const c=n.width;for(let f=0;f<o.index;f++){const y=l.positions[f];n.chars.push(l.chars[f]),n.charPositions.push(y+c)}n.width+=l.width,r=!1,o.width=0,o.index=0,o.chars.length=0},m=()=>{let l=n.chars.length-1;if(i){let c=n.chars[l];for(;c===" ";)n.width-=t.chars[c].xAdvance,c=n.chars[--l]}s.width=Math.max(s.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},r=!0,s.lines.push(n),s.height+=w},g=l=>l-h>p;for(let l=0;l<d.length+1;l++){let c;const f=l===d.length;f||(c=d[l]);const y=t.chars[c]||t.chars[" "];if(/(?:\s)/.test(c)||c==="\r"||c===`
`||f){if(!r&&e.wordWrap&&g(n.width+o.width)?(m(),S(o),f||n.charPositions.push(0)):(o.start=n.width,S(o),f||n.charPositions.push(0)),c==="\r"||c===`
`)m();else if(!f){const _=y.xAdvance+(y.kerning[a]||0)+h;n.width+=_,n.spaceWidth=_,n.spacesIndex.push(n.charPositions.length),n.chars.push(c)}}else{const F=y.kerning[a]||0,_=y.xAdvance+F+h;x&&g(n.width+o.width+_)&&(S(o),m()),o.positions[o.index++]=o.width+F,o.chars.push(c),o.width+=_}a=c}return m(),e.align==="center"?V(s):e.align==="right"?Q(s):e.align==="justify"&&tt(s),s}function V(d){for(let e=0;e<d.lines.length;e++){const t=d.lines[e],i=d.width/2-t.width/2;for(let s=0;s<t.charPositions.length;s++)t.charPositions[s]+=i}}function Q(d){for(let e=0;e<d.lines.length;e++){const t=d.lines[e],i=d.width-t.width;for(let s=0;s<t.charPositions.length;s++)t.charPositions[s]+=i}}function tt(d){const e=d.width;for(let t=0;t<d.lines.length;t++){const i=d.lines[t];let s=0,n=i.spacesIndex[s++],a=0;const r=i.spacesIndex.length,u=(e-i.width)/r;for(let h=0;h<i.charPositions.length;h++)h===n&&(n=i.spacesIndex[s++],a+=u),i.charPositions[h]+=a}}function et(d){if(d==="")return[];typeof d=="string"&&(d=[d]);const e=[];for(let t=0,i=d.length;t<i;t++){const s=d[t];if(Array.isArray(s)){if(s.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);if(s[0].length===0||s[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=s[0].charCodeAt(0),a=s[1].charCodeAt(0);if(a<n)throw new Error("[BitmapFont]: Invalid character range.");for(let r=n,o=a;r<=o;r++)e.push(String.fromCharCode(r))}else e.push(...Array.from(s))}if(e.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return e}let B=0;class st{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=G(1e3)}getFont(e,t){let i=`${t.fontFamily}-bitmap`,s=!0;if(t._fill.fill&&!t._stroke?(i+=t._fill.fill.styleKey,s=!1):(t._stroke||t.dropShadow)&&(i=`${t.styleKey}-bitmap`,s=!1),!z.has(i)){const a=Object.create(t);a._lineHeight=0;const r=new R({style:a,overrideFill:s,overrideSize:!0,...this.defaultOptions});B++,B>50&&q("BitmapText",`You have dynamically created ${B} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),r.once("destroy",()=>{B--,z.remove(i)}),z.set(i,r)}const n=z.get(i);return n.ensureCharacters?.(e),n}getLayout(e,t,i=!0){const s=this.getFont(e,t),n=`${e}-${t.styleKey}-${i}`;if(this.measureCache.has(n))return this.measureCache.get(n);const a=T.graphemeSegmenter(e),r=Z(a,t,s,i);return this.measureCache.set(n,r),r}measureText(e,t,i=!0){return this.getLayout(e,t,i)}install(...e){let t=e[0];typeof t=="string"&&(t={name:t,style:e[1],chars:e[2]?.chars,resolution:e[2]?.resolution,padding:e[2]?.padding,skipKerning:e[2]?.skipKerning},k(v,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const i=t?.name;if(!i)throw new Error("[BitmapFontManager] Property `name` is required.");t={...this.defaultOptions,...t};const s=t.style,n=s instanceof A?s:new A(s),a=t.dynamicFill??this._canUseTintForStyle(n),r=new R({style:n,overrideFill:a,skipKerning:t.skipKerning,padding:t.padding,resolution:t.resolution,overrideSize:!1,textureStyle:t.textureStyle}),o=et(t.chars);return r.ensureCharacters(o.join("")),z.set(`${i}-bitmap`,r),r.once("destroy",()=>z.remove(`${i}-bitmap`)),r}uninstall(e){const t=`${e}-bitmap`,i=z.get(t);i&&i.destroy()}_canUseTintForStyle(e){return!e._stroke&&(!e.dropShadow||e.dropShadow.color===0)&&!e._fill.fill&&e._fill.color===16777215}}const E=new st;class at extends K{constructor(e,t){super();const{textures:i,data:s}=e;Object.keys(s.pages).forEach(n=>{const a=s.pages[parseInt(n,10)],r=i[a.id];this.pages.push({texture:r})}),Object.keys(s.chars).forEach(n=>{const a=s.chars[n],{frame:r,source:o,rotate:u}=i[a.page],h=J.transformRectCoords(a,r,u,new O),p=new M({frame:h,orig:new O(0,0,a.width,a.height),source:o,rotate:u});this.chars[n]={id:n.codePointAt(0),xOffset:a.xOffset,yOffset:a.yOffset,xAdvance:a.xAdvance,kerning:a.kerning??{},texture:p}}),this.baseRenderedFontSize=s.fontSize,this.baseMeasurementFontSize=s.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:s.fontSize},this.baseLineOffset=s.baseLineOffset,this.lineHeight=s.lineHeight,this.fontFamily=s.fontFamily,this.distanceField=s.distanceField??{type:"none",range:0},this.url=t}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{texture:t}=this.pages[e];t.destroy(!0)}this.pages=null}static install(e){E.install(e)}static uninstall(e){E.uninstall(e)}}export{at as BitmapFont};
